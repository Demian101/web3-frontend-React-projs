项目 Web 地址：[https://buildspace.so/](https://buildspace.so/)

本项目 Tutorial：[https://github.com/buildspace/buildspace-projects](https://github.com/buildspace/buildspace-projects)

本项目代码：https://gist.github.com/adilanchian/93fbd2e06b3b5d3acb99b5723cebd925



```js
npx hardhat run ./scripts/run.js
npx hardhat run scripts/deploy.js --network rinkeby
> WavePortal address: 0xF0e8C3c63Af52F884BD6C0439aE64842697761D9
> check Contract： https://rinkeby.etherscan.io/address/0xC0A722E33e0A2f91d6492E385964253Fe9661369

0. 修改合约后，重新 deploy
1. 修改 App.js 里面的合约地址
2. 复制 ADD 的 json 到 Front 的 src/utils/
```



## Review : 代码阅读：

### 0. 效果展示

没有登录的话，首先要通过 MetaMask 钱包登录

<img src="/Users/soda/Library/Application Support/typora-user-images/image-20220508191021941.png" alt="image-20220508191021941" style="zoom:30%;" />

登录后：

![](http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-05-08-111648.png)



### 1. WavePortal.sol

https://github.com/numoonchld

```solidity
pragma solidity ^0.8.4;

import "hardhat/console.sol";

contract WavePortal {
    // uint256 totalWaves;
    mapping(address => uint256) private trackWaveCount;  // 记录某个 sender 挥了 x 次手。
    mapping(address => uint256) public lastWavedAt;
    uint256 private seed;

    event NewWave(address indexed from, uint256 timestamp, string message);

    struct Wave {  // 用户发送 Message 给我们的 struct 结构。
        address waver;
        string message;
        uint256 timestamp;
    }

    Wave[] waves;  // an array of structs.

    constructor() payable {    // `payable`关键字代表此函数 (contract? ) 可以接受转账 
        console.log("We have been constructed!");
        seed = (block.timestamp * block.difficulty) % 100;  // 调一些全局变量生成随机 seed
    }

    function wave(string memory _message) public {
        require(   // 需要两次 wave() 的时间间隔 > 1s
            lastWavedAt[msg.sender] + 1 seconds < block.timestamp,
            "1s cool-down for this waver active!"
        );

        lastWavedAt[msg.sender] = block.timestamp;  // 记录当前时间作为最后一次

        // totalWaves += 1;
        // console.log("%s has waved!", msg.sender);
        console.log("%s waved with message %s", msg.sender, _message);

        // 挥手、打招呼的信息记入数组
        waves.push(Wave(msg.sender, _message, block.timestamp));  

        trackWaveCount[msg.sender] += 1;  // 记录某个 sender 挥了 x 次手。

        // 随机种子，取模，保证数字在 0-99
        seed = (block.difficulty + block.timestamp + seed) % 100; 
        console.log("Random # generated: %d", seed);

        if (seed < 50) {   // 有 50% 的概率用户可以通过挥手获得 Contract 上的 eth ！
            uint256 prizeAmount = 0.0001 ether;
            require(
                // address(this).balance 指合约本身的余额，比较 2 者。
                prizeAmount <= address(this).balance,
                "Trying to withdraw more moneythan the contract has."
            );
            // 汇款的神奇线路
            (bool success, ) = (msg.sender).call{value: prizeAmount}("");
            require(success, "Failed to withdraw money from contract");
        }

        emit NewWave(msg.sender, block.timestamp, _message);
    }

    // 获取总的被人挥手的次数
    function getTotalWaves() public view returns (uint256) {  
        return waves.length;
    }

    // 查看某个交互者 和我们交互(挥手)的次数
    function getWaveCount(address interactor) public view returns (uint256) {
        console.log(
            "%s has waved %d time(s)!",
            interactor,
            trackWaveCount[interactor]
        );
        return trackWaveCount[interactor];
    }

    function getAllWaves() public view returns (Wave[] memory) {
        return waves;
    }
    // receive() external payable {}
}
```





### 2. run.js

现在我们的智能合约已经写好了，在正式部署之前，要在本地做一些测试。

通过 `hre.ethers.utils.parseEther("0.1"),` 向 payable 的 Contract 添加余额 (balance)

```js
const main = async () => {

  const [owner, randomPerson] = await hre.ethers.getSigners()

  const waveContractFactory = await hre.ethers.getContractFactory("WavePortal")
  const waveContract = await waveContractFactory.deploy({
    value: hre.ethers.utils.parseEther("0.1"),
  })  // 试图部署
  await waveContract.deployed()  // 等待部署完成

  console.log("Contract deployed to: ", waveContract.address)
  console.log("Contract deployed by: ", owner.address)

  let contractBalance = await hre.ethers.provider.getBalance(waveContract.address)
  console.log("Contract Balance:", hre.ethers.utils.formatEther(contractBalance))


  await waveContract.getWaveCount(owner.address)
  await waveContract.getWaveCount(randomPerson.address)

  let waveCount
  waveCount = await waveContract.getTotalWaves()

  let waveTxn = await waveContract.wave('message 1')  // 测试挥手 Message
  await waveTxn.wait()
  waveCount = await waveContract.getTotalWaves()
  
  // 生成随机用户的方法 randomPerson
  waveTxn = await waveContract.connect(randomPerson).wave('message 2')
  await waveTxn.wait()
  waveCount = await waveContract.getTotalWaves()

  waveTxn = await waveContract.wave('message 3')
  await waveTxn.wait()
  await waveContract.getTotalWaves()
  await waveContract.getWaveCount(owner.address)
  await waveContract.getWaveCount(randomPerson.address)

  contractBalance = await hre.ethers.provider.getBalance(waveContract.address)
  console.log("Contract Balance:", hre.ethers.utils.formatEther(contractBalance))

  let allWaves = await waveContract.getAllWaves()
  console.log(allWaves)
}

const runMain = async () => {
  try {
    await main()
    process.exit(0)
  } catch (error) {
    console.error(error)
    process.exit(1)
  }
}

runMain()
```

```js
output：
Compiled 1 Solidity file successfully
We have been constructed!
Contract deployed to:  0x5FbDB2315678afecb367f032d93F642f64180aa3
Contract deployed by:  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Contract Balance: 0.1
0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 has waved 0 time(s)!
0x70997970c51812dc3a010c7d01b50e0d17dc79c8 has waved 0 time(s)!
0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 waved with message message 1
Random # generated: 30
0x70997970c51812dc3a010c7d01b50e0d17dc79c8 waved with message message 2
Random # generated: 73
0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 waved with message message 3
Random # generated: 81
0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 has waved 2 time(s)!
0x70997970c51812dc3a010c7d01b50e0d17dc79c8 has waved 1 time(s)!
Contract Balance: 0.0999
[
  [
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    'message 1',
    BigNumber { value: "1651896942" },
    waver: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    message: 'message 1',
    timestamp: BigNumber { value: "1651896942" }
  ],
  [
    '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    'message 2',
    BigNumber { value: "1651896943" },
    waver: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    message: 'message 2',
    timestamp: BigNumber { value: "1651896943" }
  ],
  [
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    'message 3',
    BigNumber { value: "1651896944" },
    waver: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    message: 'message 3',
    timestamp: BigNumber { value: "1651896944" }
  ]
]

```



### 3. deploy.js

部署代码，把我们钱包里的币真实发送到合约。

```js
const main = async () => {
  const [deployer] = await hre.ethers.getSigners()
  const accountBalance = await deployer.getBalance()

  console.log("Account deploying contracts: ", deployer.address)
  console.log("Account balance: ", accountBalance.toString())

  const waveContractFactory = await hre.ethers.getContractFactory("WavePortal")
  const waveContract = await waveContractFactory.deploy({
    value: hre.ethers.utils.parseEther("0.001"),   // 发送 0.001 个币到链上合约。
  })
  await waveContract.deployed()

  console.log("WavePortal address: ", waveContract.address)
}

const runMain = async () => {
  try {
    await main()
    process.exit(0)
  }
  catch (error) {
    console.error(error)
    process.exit(1)
  }
}

runMain()
```



```solidity
$ npx hardhat run scripts/deploy.js --network rinkeby
Account deploying contracts:  0x65d5b68A7878A987e7A19826A7f9Aa6F5F92e10F
Account balance:  85701084573562765
WavePortal address:  0xF0e8C3c63Af52F884BD6C0439aE64842697761D9
```





### 4. App.js

大头来了，前端代码。

```react
import React, { useEffect, useState } from 'react';
import { ethers } from 'ethers';
import './App.css';
import abi from './utils/WavePortal.json';

export default function App() {
  const [inputMessage, setInputMessage] = useState('');

  // useState 赋 null 的初始值给 currentAccount，使用 setCurrentAccount 对 currentAccount 的 value 进行更改
  // 当我们连接到 MetaMask 前，useState为空  ;  当我们连接到 MetaMask 后，useState为首个账号地址
  const [currentAccount, setCurrentAccount] = useState(null);
  const [totalWaves, setTotalWaves] = useState(null);
  const [allWaves, setAllWaves] = useState([]);
  const [isMining, setIsMining] = useState(false);
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  const contractAddress = '0xF0e8C3c63Af52F884BD6C0439aE64842697761D9';
  const contractABI = abi.abi;

  const onNewWave = (from, timestamp, message) => {
    console.log('NewWave', from, timestamp, message);

    // 将 allWaves展开之前的数据（Waves,即别人和我们打招呼的 Messages）
    // 再把最新的 struct 对象 追加上去。
    setAllWaves( [
      ...allWaves,
      {
        address: from.toString(),
        timestamp: new Date(timestamp * 1000).toString(),
        message: message
      }
    ]);
  };

  // 比较 2 次打招呼之前的时间间隔，间隔不能大短。
  const compareTimestamps = (waveA, waveB) => {
    if (waveA.timestamp > waveB.timestamp) {  return -1; }
    if (waveA.timestamp < waveB.timestamp) {  return 1;  }
    return 0;
  };

  const connectWallet = async () => {
    const { ethereum } = window;  // 解包对象, window 有上千个对象，我们只要 MetaMask 注入的这个ethereum 就可以了。
    const accounts = await ethereum.request({
      // ethereum 的 eth_requestAccounts 方法是建立初始连接 MetaMask 的函数。
      method: 'eth_requestAccounts'   
    });

    const account = accounts[0];
    console.log('Connected', account);
    setCurrentAccount(account);
    setIsLoggedIn(true);
    getAllWaves();
  };

  // 输入框中需要写东西才能提交，否则就会在浏览器弹出 Alert。
  const wave = async () => {
    if (inputMessage.trim() === '') {
      alert( "Leave a comment in the text box above the 'Wave at Me' button and then hit the button!"  );
      return;
    }

    try {
      const { ethereum } = window;  // 解包对象,

      if (!ethereum) { 
        alert('Install Metamask!'); 
        return;   }

      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const wavePortalContract = new ethers.Contract(  // 连接钱包的一些配置，还记得 ABI 吗 ？
        contractAddress,
        contractABI,
        signer
      );

      const waveTxn = await wavePortalContract.wave(inputMessage, {  // 设置消耗的最大 gas
        gasLimit: 1000000
      });
      console.log('Mining: ', waveTxn.hash);   // 当有人提交了 Message 后，合约就会尝试修改变量，将其写到区块链上，这需要时间。
      setIsMining(true);

      await waveTxn.wait();
      console.log('Mined!', waveTxn.hash);  // 在区块链上改动完毕后，返回 Transaction 的 hash 值。
      setIsMining(false);

      const waves = await wavePortalContract.getAllWaves();
      setTotalWaves(waves.length);   // 设置目前和我们打招呼的招呼总数。

      const processedWaves = waves.map(wave => {
        return {
          address: wave.waver.toString(),
          timestamp: new Date(wave.timestamp * 1000).toString(),
          message: wave.message
        };
      });
      setAllWaves(processedWaves);
    } catch (error) {
        console.log(error);
        alert("If you've already waved today, come back tomorrow!");
        setIsMining(false);
    }
  };

  // 检查钱包是否链接
  const checkWalletConnection = async () => {
    try {
      const { ethereum } = window;

      if (!ethereum) {
        console.log('Install MetaMask!');
        alert('MetaMask needed to use this site!');
      } else {
        console.log('Ethereum object found!', ethereum);
      }
      // ethereum 的 eth_accounts 方法查看是否有权访问用户钱包中的帐户。
      const accounts = await ethereum.request({ method: 'eth_accounts' });

      if (accounts.length !== 0) {
        const account = accounts[0];  // 有可能拿到连接到 MetaMask 的多个账户，这里只取第一个。
        console.log('Found authorized account!', account);
        setCurrentAccount(account);
        setIsLoggedIn(true);
      } else {
        console.log('No authorized account found!');
        setIsLoggedIn(false);
      }
    } catch (error) {
      console.error(error);
    }
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const getAllWaves = async () => {
    try {
      const { ethereum } = window;

      if (!ethereum) {  alert('Install Metamask!');  return;  }

      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const wavePortalContract = new ethers.Contract(   // 连接钱包的一些配置，还记得 ABI 吗 ？
        contractAddress,
        contractABI,
        signer
      );

      const waves = await wavePortalContract.getAllWaves();
      const processedWaves = waves.map(wave => {
        return {
          address: wave.waver,
          timestamp: new Date(wave.timestamp * 1000),
          message: wave.message
        };
      });
      setAllWaves(processedWaves);
    } catch (error) {
      console.error(error);
    }
  };

  // 副作用 hook， [] 是第二个参数，因为 [] 是空数组，不会变，所以函数体操作只执行一次。
  useEffect(() => {
    let wavePortalContract;

    if (window.ethereum) {
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      const signer = provider.getSigner();

      wavePortalContract = new ethers.Contract(
        contractAddress,
        contractABI,
        signer
      );
      // ethers.contract.on 是 ethers.js 中用来监听事件Event 的。
      // https://learnblockchain.cn/docs/ethers.js/api-contract.html#id6
      //  在合约里面事件是这么写的（如下），所以说 'NewWave' 就是指合约里的事件
      //    event NewWave(address indexed from, uint256 timestamp, string message);
      // 从执行过程也可以看出，onNewWave 这个函数是在 Mining 后， Mined 完成的同时(或之后)启动、log 的。

      wavePortalContract.on('NewWave', onNewWave);
    }

    return () => {
      if (wavePortalContract) {
        // Unsubscribe listener to event.  取消订阅事件 Events 
        wavePortalContract.off('NewWave', onNewWave);
      }
    };
  }, []);

  // React hook, 副作用 hook， [] 是第二个参数，如果 [] 内的值发生变化，则执行 2 个函数
  // 因为 [] 是空数组，不会变，所以这个函数只执行一次。
  useEffect(() => {
    checkWalletConnection();
    getAllWaves();
  }, []);

  return (
    <div className="mainContainer">
	  {!isLoggedIn && (
        <button className="loginButton" onClick={connectWallet}>
          Login to MetaMask
        </button>
      )}
      {isLoggedIn && (
        <div className="dataContainer">
		  {/* 给图片加跳转链接 */}
          <a
            href="https://github.com/Sodaoo"
            // eslint-disable-next-line react/jsx-no-target-blank
            target="_blank"  >
            <img className="logo" src="https://avatars.githubusercontent.com/u/33189338?v=4"  alt="numoonchld" />
          </a>

          <div className="bio">
            <a href="https://github.com/Sodaoo"
            > Demian </a>
            
			{/* 网易云音乐的 iframe */}
            <iframe   
			  style={{ borderRadius: '12px', margin: '10px 0px 0px 0px' }} 
			  src="//music.163.com/outchain/player?type=0&id=7133315069&auto=1&height=430"
			  frameBorder="0" title="iframe2" width="100%" height="240" 
              />
            <br />

            {!isMining && (
              <div className="waveTile">
                <textarea
                  className="waveMessage"
                  placeholder="跟我打个招呼吧 ! ~ "
                  value={inputMessage}
                  onChange={event => setInputMessage(event.target.value)}
                  rows="5"
                  required
                />
                <button className="waveButton" onClick={wave}>
                  <div> Wave at Me </div>
                  <small className="totalWaves">{allWaves.length}</small>
                </button>
                <small>(ETH wallet signature required)</small>
              </div>
            )}
            {isMining && (
              <>
                <div className="miningSpinner" />
              </>
            )}
          </div>

          <div className="waveTable">
            <b style={{ marginBottom: '0%' }}>Wave Log</b>
            {allWaves.sort(compareTimestamps).map(wave => (
              <div key={Date.parse(wave.timestamp)} className="waveTableEntry">
                <small>{wave.address}</small>
                <small>{wave.timestamp.toString()}</small>
                <hr style={{ width: '100%' }} />
                {wave.message ? wave.message : '<blank message>'}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```











## 项目目标

React web3 应用程序 + 以太坊智能合约。 

Big Picture：

1. **We're going to write a smart contract.** That contract like your server code.

2. **Our smart contract will be deployed to the blockchain.** This way, anyone in the world will be able to access and run our smart contract (if we give them permission to do so)

3. **We're going to build a client website** that will let people easily interact with our smart contract on the blockchain.



Hardhat 介绍：

>  Hardhat是一个编译、部署、测试和调试以太坊应用的开发环境。它可以帮助开发人员管理和自动化构建智能合约和dApps过程中固有的重复性任务，并围绕这一工作流程轻松引入更多功能。这意味着hardhat在最核心的地方是编译、运行和测试智能合约。
>
> Hardhat内置了Hardhat网络，这是一个专为开发设计的本地以太坊网络。主要功能有Solidity调试，跟踪调用堆栈、`console.log()`和交易失败时的明确错误信息提示等。



### 环境部署

1. 下载 VS Code 高亮扩展 ：[here](https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity)

2. 下载 Node.js 最新版本

```solidity
mkdir my-wave-portal
cd my-wave-portal
npm init -y
npm install --save-dev hardhat

npx hardhat

npm install --save-dev @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers
```

> 注意：如果你在 npm 的同时安装了 yarn，你可能会得到 npm ERR 之类的错误！无法确定要运行的可执行文件。在这种情况下，你可以 `yarn add hardhat` 
> 



Finally, run `npx hardhat accounts` and this should print out a bunch of strings that look like this:

`0xa0Ee7A142d267C1f36714E4a8F75612F20a79720`

这些是 Hardhat 为我们生成的以太坊地址，用于模拟区块链上的真实用户。当我们想模拟用户对我们的攻击时，这将在项目后期帮助我们很多！

To make sure everything is working, run:

```
 npx hardhat compile
```

Then run:

```
npx hardhat test
```



Remove  (不要删除实际的文件夹! ): 

- ./test/sample-test.js
- ./scripts/sample-script.js
- ./contracts/Greeter.sol



## A smart contract 

Let's build a smart contract 

```solidity
// 文件地址：    ./my-wave-portal/contracts/WavePortal.sol

// SPDX-License-Identifier: UNLICENSED

// 注意确保版本和 hardhat.config.js  中的一样。
pragma solidity ^0.8.4;

import "hardhat/console.sol";

contract WavePortal {
    constructor() {
        console.log("Yo yo, I am a contract and I am smart");
    }
}
```

创建好一份 Contract 后，只需：

1. 编译它。

2. 将其部署到我们的本地区块链。

创建一个脚本开运行合约：

```solidity
//  ./scripts/run.js

const main = async () => {
  // hre.ethers  后续会讲。
  const waveContractFactory = await hre.ethers.getContractFactory("WavePortal");

  // 编译我们的合约并在 artifacts 目录下生成我们使用合约所需的必要文件。运行后去检查一下:)。
  const waveContract = await waveContractFactory.deploy();

  // Hardhat 将为我们创建一个本地以太坊网络，but just for this contract
  // after the script completes it'll destroy that local network.
  //所以，每次运行合约时，它都会是一个全新的区块链,这使得 Debug 变得容易
  await waveContract.deployed();

  //waveContract.address 会为我们提供部署在 Blockchain 的合约的地址. 
  console.log("Contract deployed to:", waveContract.address);
};

const runMain = async () => {
  try {
    await main();
    process.exit(0); // exit Node process without error
  } catch (error) {
    console.log(error);
    process.exit(1); // exit Node process while indicating 'Uncaught Fatal Exception' error
  }
  // Read more about Node exit ('process.exit(num)') status codes here: https://stackoverflow.com/a/47163396/7974948
};

runMain();
```

Run it ！ ：

```solidity
$ npx hardhat run ./scripts/run.js

Output:
  Downloading compiler 0.8.4
  Compiled 2 Solidity files successfully
  Yo yo, I am a contract and I am smart
  Contract deployed to: 0x5FbDB2315678afecb367f032d93F642f64180aa3
```

`hre.ethers:`

直接从 Hardhat 文档本身，您会注意到这一点：

Hardhat Runtime Environment，或简称 HRE，是一个包含 Hardhat 在运行任务、测试或脚本时公开的所有功能的对象。实际上，Hardhat 就是 HRE。

那么这是什么意思？好吧，每次您运行以 `npx hardhat` 开头的终端命令时，都会使用代码中指定的 hardhat.config.js 动态构建这个 hre 对象！这意味着您将永远不必实际对文件进行某种导入，例如：

```solidity
const hre = require("hardhat")
```

Hardhat 文档： **[Hardhat documentation](https://hardhat.org/advanced/hardhat-runtime-environment.html)**

更进一步：

- 记录合约调用者挥手 (wave)👋🏻 的次数。

```solidity
//   ./contracts/WavePortal.sol

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.4;

import "hardhat/console.sol";

contract WavePortal {
    uint256 totalWaves;

    constructor() {
        console.log("Yo yo, I am a contract and I am smart");
    }

    function wave() public {
        totalWaves += 1;

        // 调用函数的人的钱包地址
        console.log("%s has waved!", msg.sender);
    }

    function getTotalWaves() public view returns (uint256) {
        console.log("We have %d total waves!", totalWaves);
        return totalWaves;
    }
}
```

同步修改 `run.js`

```jsx
//  ./scripts/run.js

const main = async () => {
  // VS Code 会自动 import hre.ethers
  const [owner, randomPerson] = await hre.ethers.getSigners();
  const waveContractFactory = await hre.ethers.getContractFactory("WavePortal");
  const waveContract = await waveContractFactory.deploy();
  await waveContract.deployed();

  console.log("Contract deployed to:", waveContract.address);
  console.log("Contract deployed by:", owner.address);

  let waveCount;
  //  看看有没有人挥手
  waveCount = await waveContract.getTotalWaves();

  // 自己挥一次
  let waveTxn = await waveContract.wave();
  await waveTxn.wait();

  //  再看看有没有人挥手，有一次了。
  waveCount = await waveContract.getTotalWaves();
};

const runMain = async () => {
  try {
    await main();
    process.exit(0);
  } catch (error) {
    console.log(error);
    process.exit(1);
  }
};

runMain();
```

> 为了将某些东西部署到区块链上，我们需要有一个钱包地址！ Hardhat 在后台神奇地为我们做这件事， by ： `const [owner, randomPerson] = await hre.ethers.getSigners();`
> 



**Test other users (让其他人也能调用函数！)**

```jsx
//   ./scripts/run.js

const main = async () => {
  const [owner, randomPerson] = await hre.ethers.getSigners();
  const waveContractFactory = await hre.ethers.getContractFactory("WavePortal");
  const waveContract = await waveContractFactory.deploy();
  await waveContract.deployed();

  console.log("Contract deployed to:", waveContract.address);
  console.log("Contract deployed by:", owner.address);

  let waveCount;
  waveCount = await waveContract.getTotalWaves();

  let waveTxn = await waveContract.wave();
  await waveTxn.wait();

  waveCount = await waveContract.getTotalWaves();

  // Attention HERE
  waveTxn = await waveContract.connect(randomPerson).wave();
  await waveTxn.wait();

  waveCount = await waveContract.getTotalWaves();
};

const runMain = async () => {
  try {
    await main();
    process.exit(0);
  } catch (error) {
    console.log(error);
    process.exit(1);
  }
};

runMain();
```



## 本地部署，以便我们可以开始构建网站

当您运行 scripts/run.js 时，它实际上是

1. 创建一个新的本地以太坊网络。

2. 部署合约。

3. 脚本结束后，Hardhat 会自动销毁该本地网络。

所以我们需要建立一个本地的服务器。

```jsx
cd /my-wave-portal
npx hardhat node
```

执行 npx 后，Hardhat 为我们提供了 20 个帐户，并为他们提供了全部 10000 ETH

新建 deploy.js，It looks super similar to `run.js`

```jsx
//   scripts/deploy.js
const main = async () => {
    const [deployer] = await hre.ethers.getSigners();
    const accountBalance = await deployer.getBalance();
  
    console.log("Deploying contracts with account: ", deployer.address);
    console.log("Account balance: ", accountBalance.toString());
  
    const waveContractFactory = await hre.ethers.getContractFactory("WavePortal");
    const waveContract = await waveContractFactory.deploy();
    await waveContract.deployed();
  
    console.log("WavePortal address: ", waveContract.address);
  };
  
  const runMain = async () => {
    try {
      await main();
      process.exit(0);
    } catch (error) {
      console.log(error);
      process.exit(1);
    }
  };
  
  runMain();
```

现在我们要运行以在本地部署的命令是：

```jsx
$ 新建一个 Terminal
$ npx hardhat run scripts/deploy.js --network localhost

Output :
Deploying contracts with account:  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Account balance:  10000000000000000000000
WavePortal address:  0x5FbDB2315678afecb367f032d93F642f64180aa3
```

Sever 的 log 页面：

```jsx
web3_clientVersion (2)
eth_accounts
eth_chainId (2)
eth_getBalance
eth_accounts
eth_blockNumber
eth_chainId (2)
eth_estimateGas
eth_getBlockByNumber
eth_feeHistory
eth_sendTransaction
  Contract deployment: WavePortal
  Contract address:    0x5fbdb2315678afecb367f032d93f642f64180aa3
  Transaction:         0x67b70ba926729db02394ce581ec46acf40412cd1d51849753cabdd93f6ffc37a
  From:                0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
  Value:               0 ETH
  Gas used:            355200 of 355200
  Block #1:            0x04d0b2446404ea561895006b424d9a2431d1338e94f18fb54da854ac26e62b8d

  console.log:
    Yo yo, I am a contract and I am smart

eth_chainId
eth_getTransactionByHash
eth_chainId
eth_getTransactionReceipt
```



## Setup a React app，设置 Metamask

> 没用这玩意，直接在本地起的 React 。

了解前端如何与我们的合约交互！

使用 [Replit](https://replit.com/~) 来构建前端站点： 它是一个基于浏览器的 IDE，可让我们轻松构建 Web 应用程序并从浏览器中部署它们(预览 React 代码的效果)

<img src="http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-05-08-Untitled.png" style="zoom: 33%;" />

可以直接在这里 Fork ： [https://replit.com/@adilanchian/waveportal-starter-project?v=1](https://replit.com/@adilanchian/waveportal-starter-project?v=1)

点击 Fork，点击 Run，一旦它停止加载并向您显示一些代码，请单击顶部的“运行”按钮。第一次这可能需要 2-3 分钟。基本上，Replit 正在启动您的项目并将其部署到实际域。

> **In Replit, if you are creating any new JavaScript files, you will need to use the `.jsx` extension instead! Replit has some performance fanciness that requires you use the `.jsx` file extension :).**
> 

直接 Download git （[https://github.com/buildspace/waveportal-starter-project](https://github.com/buildspace/waveportal-starter-project)） ：

1. Run `npm install` at the root of your directory
2. Run `npm run start` to start the project

React 首次启动有点慢，大概等 10 s 左右：

![](http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-05-08-Untitled%201.png)



## Alchemy

在 Alchemy [here](https://alchemy.com/?r=b93d1f12b8828a57) 创建账户，以便交互到 BlockChain 网络。

当我们部署合约时，我们需要告诉所有这些矿工，“嘿，这是一个新的智能合约，请将我的智能合约添加到区块链中，然后也告诉其他人”。

这就是 Alchemy （炼金术）的用武之地。

Alchemy 本质上帮助我们广播我们的合约创建交易，以便它可以被矿工尽快拾取。一旦交易被挖掘出来，它就会作为合法交易被广播到区块链上。从那里，每个人都会更新他们的区块链副本。

1. Create APP 
2. 选择非 ETH 网络，我们将从以太坊基金会的“Rinkeby 测试网”开始，它是“主网”的克隆，但它使用假 $，因此我们可以尽可能多地测试东西。
3. 创建后来到 Dashboard，点击 view key 查看

我们可以在实际场景中测试我们的应用程序：

1. 广播我们的交易
2. 等待实际矿工领取
3. 等待它被开采
4. 等待它被广播回区块链，告诉所有其他矿工更新他们的副本

为了获得假 ETH，我们必须向网络索取一些。这个假的 ETH 只能在这个特定的测试网上工作。

- [https://faucets.chain.link/rinkeby](https://faucets.chain.link/rinkeby)
    - 这个网站可以获得 0.1 ETH

MetaMask 添加 Rinkeby 测试网：

1. Go  [https://chainlist.org/](https://chainlist.org/)
2. toggle Testnets Button
3. Search “Rinkeby”
4. Connect 

> 部分 MetaMask 钱包好像自带 Rinkeby 测试网，就不用添加了。
> 

### **Deploy to Rinkeby testnet**

```jsx
//   hardhat.config.js  修改
//  这样很危险，后面说明

require("@nomiclabs/hardhat-waffle");

module.exports = {
  solidity: "0.8.4",
  networks: {
    rinkeby: {
      url: "YOUR_ALCHEMY_API_URL",
      accounts: ["YOUR_PRIVATE_RINKEBY_ACCOUNT_KEY"]
    },
  },
};
```

> Note： 此私钥与您的主网私钥相同， **DON'T COMMIT THIS FILE TO GITHUB**
> 

最好的方法是将 hardhat 配置文件添加到 .gitignore ，从而避免 upload 。 **

另一种保证 hardhat.config.js 安全的方法是使用 dotenv （ 安装： `npm i --save dotenv` ）：

```jsx
//   hardhat.config.js  修改
// 使用 dotenv,  避免 upload hardhat.config.js
require("@nomiclabs/hardhat-waffle");

// Import and configure dotenv
require("dotenv").config();

module.exports = {
  solidity: "0.8.4",
  networks: {
    rinkeby: {
      // This value will be replaced on runtime
      url: process.env.STAGING_ALCHEMY_KEY,
      accounts: [process.env.PRIVATE_KEY],
    },
    mainnet: {
      chainId: 1,
      url: process.env.PROD_ALCHEMY_KEY,
      accounts: [process.env.PRIVATE_KEY],
    },
  },
};
```

在 root 文件夹中，创建一个 .env 文件并添加您的 secrets ：

```jsx
STAGING_ALCHEMY_KEY=REPLACE_WITH_ACTUAL_ALCHEMY_URL  // HTTP： https://eth-rinkeby.alchemyapi.io...
PROD_ALCHEMY_KEY=BLAHBLAH  // API Key : UCT.........
PRIVATE_KEY=BLAHBLAH       // 私钥
```

最后，将 .env 文件添加到您的 .gitignore 文件中 (一般 `.env`  默认在 `.gitignore` 里面)

> 私钥可以在 MetaMask 导出 ： 「 三点 - 账户详情 - 导出私钥」
> 

为什么需要私钥？

> 因为为了执行像部署合约这样的交易，需要 "login” 到区块链。而且，您的用户名是您的公共地址，您的密码是您的私钥。这有点像登录 AWS 或 GCP 进行部署。
> 

一旦你完成了配置设置，我们就可以使用我们之前编写的部署脚本进行部署。从 my-wave-portal 的根目录运行此命令。请注意，我们所做的只是将其从 localhost 更改为 rinkeby：

```jsx
npx hardhat run scripts/deploy.js --network rinkeby

Output :
Deploying contracts with account:  0x65d5b68A7878A987e7A19826A7f9Aa6F5F92e10F
Account balance:  100000000000000000
WavePortal address:  0xC73BC1952694D49AfbB82563aD8D2780132F9F2D  (合约地址)
```

可以在 [https://rinkeby.etherscan.io/](https://rinkeby.etherscan.io/) 查看部署在 Rinkeby 上的 Smart Contract 地址：

![](http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-05-08-Untitled%202.png)



## React Connect Wallet

一旦我们将钱包连接到我们的网站，我们的网站将有权代表我们调用智能合约。

MetaMask 的 **window** 属性：

> when MetaMask is installed, the window object has an `ethereum`
 property to interact with (交互) .  When you call this function, your MetaMask extension should open and ask what account you would like to connect to.
> 

> 当您调用此函数时，您的 MetaMask 扩展程序应该打开并询问您要连接到哪个帐户。
> 

> 也就是说，当我们的浏览器登录到了 Metamask，它会自动将一个名为 `ethereum` 的特殊对象注入我们的窗口（window）,可以通过 `window.ethereum` 调用。
> 

- ethereum 的 eth_accounts 方法查看是否有权访问用户钱包中的帐户。
- ethereum 的 eth_requestAccounts 方法是建立初始连接 MetaMask 的函数。

```jsx
//   frontend/src/App.js
import './App.css';
import React, { useEffect,useState } from "react";

const App = () => {
  // useState 赋 "" 的初始值给 currentAccount，使用 setCurrentAccount 对 currentAccount 的 value 进行更改
  // 当我们连接到 MetaMask 前，useState为空，
  // 当我们连接到 MetaMask 后，useState为首个账号地址 ~
  const [currentAccount, setCurrentAccount] = useState("");

  const checkIfWalletIsConnected = async () => {
    try {
      const { ethereum } = window;   // 解包对象

      if (!ethereum) {
        console.log("Make sure you have metamask!");  // 解包出来为空，说明没有安装(登录)钱包
        return;
      } else {
        console.log("We have the ethereum object", ethereum);
      }

      // 使用特殊方法 eth_accounts 查看是否有权访问用户钱包中的帐户。(用户钱包中可能有多个帐户, 这里取 No.1 个)
      const accounts = await ethereum.request({ method: "eth_accounts" });

      if (accounts.length !== 0) {
        const account = accounts[0];
        console.log("Found an authorized account:", account);
        setCurrentAccount(account);
      } else {
        console.log("No authorized account found")
      }
    } catch (error) {
      console.log(error);
    }
  }

  /**  Implement your connectWallet method here  */
  const connectWallet = async () => {
    try {
      const { ethereum } = window;

      if (!ethereum) {
        alert("Get MetaMask!");
        return;
      }

      // eth_requestAccounts 是建立初始连接 MetaMask 的函数。
      const accounts = await ethereum.request({ method: "eth_requestAccounts" });

      console.log("Connected", accounts[0]);
      setCurrentAccount(accounts[0]);
    } catch (error) {
      console.log(error)
    }
  }

  // This runs our function when the page loads.
  useEffect(() => {
    checkIfWalletIsConnected();
  }, [])

  return (
    <div className="mainContainer">
      <div className="dataContainer">
        <div className="header">
        👋 Hey there!
        </div>

        <div className="bio">
          I am farza and I worked on self-driving cars so that's pretty cool right? Connect your Ethereum wallet and wave at me!
        </div>

        <button className="waveButton" onClick={null}>
          Wave at Me
        </button>

        {/*
        * currentAccount 是 checkIfWalletIsConnected 返回的变量，这个变量标识了当前是否连接到了 Wallet。
          1. If there is no currentAccount render this button。
          2. 如果连接到了 Wallet，就不 render this button。 
        */}
        {!currentAccount && (
          <button className="waveButton" onClick={connectWallet}>
            Connect Wallet
          </button>
        )}
      </div>
    </div>
  );
}

export default App
```

<img src="http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-05-08-Untitled%203.png" style="zoom: 33%;" />

点击 Connect 后：

![](http://imagesoda.oss-cn-beijing.aliyuncs.com/Sodaoo/2022-05-08-Untitled%204.png)



## React calls Contract

`ethers.providers` : `providers` is an abstraction of a connection to the Ethereum network，为standard Ethereum node functionality (标准以太坊节点功能) 提供简洁、一致的接口。

`signer` : `ethers.signer` is an abstraction of an Ethereum Account，可用于对消息和交易进行签名，并将签名的交易发送到以太坊网络以执行状态更改操作。 about [signer](https://docs.ethers.io/v5/api/signer/#signers)

`ABI`（Application Binary Interface） : 编译一个合约时，会在 workspace 下创建一堆文件，ABI 就是这些文件之一。

ABI 地址：`${workspace}/artifacts/contracts/WavePortal.sol/WavePortal.json` 中

将这个文件 Copy 到 Frontend ： `./src/utils/WavePortal.json` 

> ABI :  EVM（以太坊虚拟机）是以太坊网络的核心组件，智能合约是存储在以太坊区块链上的代码片段，在 EVM 上执行。用 Solidity 或 Vyper 等高级语言编写的智能合约需要编译成 EVM 可执行字节码；部署智能合约时，此字节码存储在区块链上并与地址相关联。对于以太坊和 EVM，智能合约就是这个字节码序列。要访问用高级语言定义的函数，用户需要将名称和参数转换为字节表示，以便字节码使用它。为了解释响应中发送的字节，用户需要转换回用高级语言定义的返回值元组。为 EVM 编译的语言对这些转换保持严格的约定，但为了执行它们，必须知道与操作相关的精确名称和类型。 **ABI 精确地记录了这些名称和类型，易于解析的格式**，在人为的方法调用和可发现且可靠的智能合约操作之间进行转换。
> 

```jsx
//  src/App.js

import React, { useEffect, useState } from "react";
import { ethers } from "ethers";
import './App.css';
import abi from './utils/WavePortal.json';

const App = () => {
  const [currentAccount, setCurrentAccount] = useState("");

  // 部署的合约的地址  （  WavePortal address:  0xC73BC1952694D49AfbB82563aD8D2780132F9F2D
  const contractAddress = "0xC73BC1952694D49AfbB82563aD8D2780132F9F2D";
  const contractABI = abi.abi;
  
  const checkIfWalletIsConnected = async () => {
    try {
      const { ethereum } = window;

      if (!ethereum) {
        console.log("Make sure you have metamask!");
        return;
      } else {
        console.log("We have the ethereum object", ethereum);
      }

      const accounts = await ethereum.request({ method: 'eth_accounts' });

      if (accounts.length !== 0) {
        const account = accounts[0];
        console.log("Found an authorized account:", account);
        setCurrentAccount(account)
      } else {
        console.log("No authorized account found")
      }
    } catch (error) {
      console.log(error);
    }
  }

  const connectWallet = async () => {
    try {
      const { ethereum } = window;

      if (!ethereum) {
        alert("Get MetaMask!");
        return;
      }

      const accounts = await ethereum.request({ method: "eth_requestAccounts" });

      console.log("Connected", accounts[0]);
      setCurrentAccount(accounts[0]); 
    } catch (error) {
      console.log(error)
    }
  }

  const wave = async () => {
    try {
      const { ethereum } = window;

      if (ethereum) {
        const provider = new ethers.providers.Web3Provider(ethereum);
        const signer = provider.getSigner();
        const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);

        let count = await wavePortalContract.getTotalWaves();
        console.log("Retrieved total wave count...", count.toNumber());

        // 调用合约里的 wave() 函数，还记得吗，wave() 中有一个 variable ：totalWaves += 1;
        // 合约的 wave() 没有返回值，我理解这里的 waveTxn 是 Promise 的解析值（resolved value）
        const waveTxn = await wavePortalContract.wave();
        console.log("Mining...", waveTxn.hash);  // 打印 hash value

        // waveTxn 能调用 wait() 说明已经执行完毕了，此时已 Mint 完毕。
        // console.log(waveTxn) 看了一下，不是 await 的通用对象，而是合约返回的某种对象，所以才有 wait() 这个函数，怪不得我没搜到。。。
        await waveTxn.wait();
        console.log("Mined -- ", waveTxn.hash);

        // 再看看目前的取回的 挥手数 是多少。
        count = await wavePortalContract.getTotalWaves();
        console.log("Retrieved total wave count...", count.toNumber());
      } else {
        console.log("Ethereum object doesn't exist!");
      }
    } catch (error) {
      console.log(error)
    }
  }
  
  // React hook, [] 是第二个参数，如果 [] 内的值发生变化，则执行 checkIfWalletIsConnected
  // 因为 [] 是空数组，不会变，所以这个函数只执行一次。
  useEffect(() => {
    checkIfWalletIsConnected();
  }, [])
  
  return (
    <div className="mainContainer">
      <div className="dataContainer">
        <div className="header">
        👋 Hey there!
        </div>

        <div className="bio">
          I am farza and I worked on self-driving cars so that's pretty cool right? Connect your Ethereum wallet and wave at me!
        </div>

        // 点击 触发 wave 函数，totalWaves += 1; （写在合约里的， 这个参数会被保存到链上）
        <button className="waveButton" onClick={wave}>
          Wave at Me
        </button>

        {!currentAccount && (
          <button className="waveButton" onClick={connectWallet}>
            Connect Wallet
          </button>
        )}
      </div>
    </div>
  );
}

export default App
```

All code ： [https://gist.github.com/adilanchian/71890bf4fcd8f78e94c77cf694b24659](https://gist.github.com/adilanchian/71890bf4fcd8f78e94c77cf694b24659)

注意：

- 读取合约里的 variable 是不需要 Gas 的
- 但是修改合约中的 variable （totalWaves）是对区块的修改，交易需要矿工确认（the transaction can be mined），所以需要 gas 费。
- 在交易被 mined 时，您实际上可以打印出交易哈希，将其复制/粘贴到 Etherscan，并实时查看它的处理过程

### QA：

在 js 中調用合約有幾個可以留意的事情:

1. 这个函数产生交易
  1a.这个函数也返回值 -  有产生交易的函数如果有返回值, 其他合约可以使用这个返回值 (in solidtiy) 但在 js 这端不会拿到这个值, 我们只会拿到这个交易, 你前面提到的这个 "某种对象" 就是所谓的 receipt (收据), 在 typescript 他是 TransactionResponse, 这个类型会存在 wait 函数, 接口可以看看:

[https://docs.ethers.io/v5/api/providers/types/#providers-TransactionResponse](https://docs.ethers.io/v5/api/providers/types/#providers-TransactionResponse)

1b. 这个函数没有返回值 - 没有问题, js 端仍然只会收到 receipt
所以在 js 中如果我们要看函数调用, 最安全的方式还是不断的看 event , 从 event 看一些 log 比较好

2. 这个函数没有产生交易
2a. 这个函数有返回值 - 如果这个函数是静态没有改变状态, 那就会返回合约中的函数, 你的 wave 因为有改动到状态, 就不符合 callStatic 的需求：

[https://docs.ethers.io/v5/api/contract/contract/#contract-callStatic](https://docs.ethers.io/v5/api/contract/contract/#contract-callStatic)

2b. 这个函数没有返回值 - 一样只会拿到 receipt

不知道这样有没有清楚~~

> 给大佬跪了
> 

Alex ： 链上交互全部都是异步的，web3js返回的都是promise。

没有差别的，底层都是一样，都是json rpc，abi encode参数而已。



## Storing messages from users on the blockchain

希望我们的 APP 继续添加以下功能：

1. Let users submit a message to blockchain
2. Have that data saved somehow on the blockchain.
3. 在网站上显示这些数据，以便任何人都可以看到向我们挥手的人、Their Message、Comment。

Solidity Events ：

> 在介绍 Events 前，我们先明确 Events ，日志这两个概念。Events 发生后被记录到区块链上成为了日志。总的来说，Events 强调功能，一种行为； 日志强调存储，内容。
> 

> Events 是以太坊 EVM 提供的一种日志基础设施。Events 可以用来做操作记录，存储为日志。也可以用来实现一些交互功能，比如通知UI，返回函数调用结果等
> 

> Emit 关键字用于在solidity 中发出（发射）一个 Events，该 Events 可以被 Dapp 中的客户端读取。Solidity 事件用于记录区块链中发生的交易。
> 

```jsx
//   ./contracts/WavePortal.sol

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.4;

import "hardhat/console.sol";

contract WavePortal {
    uint256 totalWaves;

    // Declare an Event
    event NewWave(address indexed from, uint256 timestamp, string message);

    // 用户发送 Message 给我们的 struct 结构。
    struct Wave {
        address waver;     // The address of the user who waved.
        string message;    // The message the user sent.
        uint256 timestamp; // The timestamp
    }

    // an array of structs.
    Wave[] waves;

    constructor() {     console.log("I AM SMART CONTRACT. POG.");     }

    /*  _message 是 Users 发给 Contract 的消息  */
    function wave(string memory _message) public {
        totalWaves += 1;
        console.log("%s waved w/ message %s", msg.sender, _message);
        /* 有人调用 wave()， 就 push 信息到数组里面 */
        waves.push(Wave(msg.sender, _message, block.timestamp));

        /*  前面 Event 声明了 NewWave，现在让我们提交(发射)它 ! */
        emit NewWave(msg.sender, block.timestamp, _message);
    }

    /* retrieve the waves from our website!  */
    function getAllWaves() public view returns (Wave[] memory) {
        return waves;
    }

    function getTotalWaves() public view returns (uint256) {
        // Optional: Add this line if you want to see the contract print the value!
        // We'll also print it over in run.js as well.
        console.log("We have %d total waves!", totalWaves);
        return totalWaves;
    }
}
```

updated `run.js`

```jsx
//  ./scripts/run.js

const main = async () => {
    const waveContractFactory = await hre.ethers.getContractFactory("WavePortal");
    const waveContract = await waveContractFactory.deploy();
    await waveContract.deployed();
    console.log("Contract addy:", waveContract.address);
  
    let waveCount;
    waveCount = await waveContract.getTotalWaves();
    console.log(waveCount.toNumber());
  
    /** Let's send a few waves!  */
    let waveTxn = await waveContract.wave("A message!");
    await waveTxn.wait();  // Wait for the transaction(交易) to be mined
  
    const [_, randomPerson] = await hre.ethers.getSigners();
    waveTxn = await waveContract.connect(randomPerson).wave("Another message!");
    await waveTxn.wait();  // Wait for the transaction(交易) to be mined
  
    let allWaves = await waveContract.getAllWaves();
    console.log(allWaves);
  };
  
  const runMain = async () => {
    try {
      await main();
      process.exit(0);
    } catch (error) {
      console.log(error);
      process.exit(1);
    }
  };
  
  runMain();
```

```jsx
npx hardhat run scripts/run.js

Output:
Compiled 1 Solidity file successfully
I AM SMART CONTRACT. POG.
Contract addy: 0x5FbDB2315678afecb367f032d93F642f64180aa3
We have 0 total waves!
0
0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 waved w/ message A message!
0x70997970c51812dc3a010c7d01b50e0d17dc79c8 waved w/ message Another message!
[
  [
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    'A message!',
    BigNumber { value: "1651842056" },
    waver: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    message: 'A message!',
    timestamp: BigNumber { value: "1651842056" }
  ],
  [
    '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    'Another message!',
    BigNumber { value: "1651842057" },
    waver: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    message: 'Another message!',
    timestamp: BigNumber { value: "1651842057" }
  ]
]
```



### **Re-deploy**

既然我们已经更新了合约，我们需要做一些事情：

1. We need to deploy it again.

2. We need to update the contract address on our frontend.

3. We need to update the abi file on our frontend.

**People constantly forget to do these 3 steps when they change their contract. Don't forget !**

为什么我们需要做这一切？嗯，这是因为智能合约是不可变的。他们无法改变。它们是永久性的。这意味着更改合同需要完全重新部署。这也将重置所有变量，因为它将被视为全新的合同。这意味着如果我们想更新合约的代码，我们会丢失所有的 wave 数据

所以你现在需要做的是：

1. 使用 `npx hardhat run scripts/deploy.js --network rinkeby` 再次部署
2. 将 App.js 中的 `contractAddress` 更改为我们在终端中通过上述步骤获得的新合约地址，就像我们第一次部署之前所做的一样。
3. 像以前一样从工件中获取更新的 abi 文件，然后像以前一样将其复制到  `Frontend/src/utils` 中。

**再说一遍——每次更改合约代码时都需要这样做。**

```jsx
Deploying contracts with account:  0x65d5b68A7878A987e7A19826A7f9Aa6F5F92e10F
Account balance:  97891951082571324
WavePortal address:  0x605076bC8f2aA5562C021f267f03Af1eFFAEc7C5  (新的合约地址)
```

### **Hooking it all up to Frontend**

没跑通

`App.js` 添加一个函数：



update render 部分：

```jsx
return (
    <div className="mainContainer">
      <div className="dataContainer">
        <div className="header">
          👋 Hey there!
        </div>

        <div className="bio">
          I am farza and I worked on self-driving cars so that's pretty cool right? Connect your Ethereum wallet and wave at me!
        </div>

        <button className="waveButton" onClick={wave}>
          Wave at Me
        </button>

        {!currentAccount && (
          <button className="waveButton" onClick={connectWallet}>
            Connect Wallet
          </button>
        )}

        {allWaves.map((wave, index) => {
          return (
            <div key={index} style={{ backgroundColor: "OldLace", marginTop: "16px", padding: "8px" }}>
              <div>Address: {wave.address}</div>
              <div>Time: {wave.timestamp.toString()}</div>
              <div>Message: {wave.message}</div>
            </div>)
        })}
      </div>
    </div>
  );
```

### 资助合约，设置奖品，送用户以太坊

轻松向用户发送 ETH 是智能合约的核心部分，也是它们最酷的部分之一

首先，我们将给每个向我们挥手致意的人 0.0001 ETH

Update WavePortal.sol

```solidity
function wave(string memory _message) public {
    totalWaves += 1;
    console.log("%s has waved!", msg.sender);

    waves.push(Wave(msg.sender, _message, block.timestamp));

    emit NewWave(msg.sender, block.timestamp, _message);

    uint256 prizeAmount = 0.0001 ether;
    // require 就像一个花哨的 if, True 则执行， Fasle 则退出功能并取消交易
    require(
        // address(this).balance 指合约本身的余额，比较 2 者。
        prizeAmount <= address(this).balance,
        "Trying to withdraw more money than the contract has."
    );
    // 汇款的神奇线路
    (bool success, ) = (msg.sender).call{value: prizeAmount}("");
    require(success, "Failed to withdraw money from contract.");
}
```

### 为合约注入资金(Fund the contract)

我们将首先在 run.js 测试。请记住，run.js 就像我们的测试场，我们希望在部署之前确保我们的合约核心功能正常工作。同时调试合约代码和前端代码真的很困难，所以，需要把它依次 Debug ！

```jsx
const main = async () => {
  const waveContractFactory = await hre.ethers.getContractFactory("WavePortal");
  const waveContract = await waveContractFactory.deploy({
    // 从钱包中提取 ETH，来为合约提供 0.1 ETH 资金
    value: hre.ethers.utils.parseEther("0.1"),
  });
  await waveContract.deployed();
  console.log("Contract addy:", waveContract.address);

  /*
   * Get Contract balance
   */
  let contractBalance = await hre.ethers.provider.getBalance(
    waveContract.address
  );
  console.log(
    "Contract balance:",
    hre.ethers.utils.formatEther(contractBalance)
  );

  /*
   * Send Wave
   */
  let waveTxn = await waveContract.wave("A message!");
  await waveTxn.wait();

  /*
   * Get Contract balance to see what happened!
   */
  contractBalance = await hre.ethers.provider.getBalance(waveContract.address);
  console.log(
    "Contract balance:",
    hre.ethers.utils.formatEther(contractBalance)
  );

  let allWaves = await waveContract.getAllWaves();
  console.log(allWaves);
};

const runMain = async () => {
  try {
    await main();
    process.exit(0);
  } catch (error) {
    console.log(error);
    process.exit(1);
  }
};

runMain();
```

调用 `npx hardhat run scripts/run.js` 会报错，因为合约中没有添加 `payable` property：

```solidity
constructor() payable {
  console.log("We have been constructed!");
}
```

then run `npx hardhat run scripts/run.js` 

```solidity
Output:
We have been constructed!
Contract addy: 0x5FbDB2315678afecb367f032d93F642f64180aa3
Contract balance: 0.1
0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 has waved!
Contract balance: 0.0999
[
  [
    '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    'A message!',
    BigNumber { value: "1651886986" },
    waver: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    message: 'A message!',
    timestamp: BigNumber { value: "1651886986" }
  ]
]
```

make a small update to `deploy.js`

```solidity
const main = async () => {
  const waveContractFactory = await hre.ethers.getContractFactory("WavePortal");
  const waveContract = await waveContractFactory.deploy({
    // 发送极少数的 ETH 进行 Deploy ，毕竟上去了就没了，这只是 Test Contract ...  
    value: hre.ethers.utils.parseEther("0.001"),
  });

  await waveContract.deployed();

  console.log("WavePortal address: ", waveContract.address);
};

const runMain = async () => {
  try {
    await main();
    process.exit(0);
  } catch (error) {
    console.error(error);
    process.exit(1);
  }
};

runMain();
```

then `npx hardhat run scripts/deploy.js --network rinkeby` 

```solidity
output:
WavePortal address:  0xa41D211d208d151fa8Ce49992aE778B098DAFf97
```

Now when you go to [Etherscan](https://rinkeby.etherscan.io/) and paste in your contract address you'll see that your contract now has a value of **0.001 ETH**!

截至目前的代码 ： [https://github.com/helloitsm3/buildspace-solutions/blob/create-your-first-smart-contract/my-wave-portal/contracts/WavePortal.sol](https://github.com/helloitsm3/buildspace-solutions/blob/create-your-first-smart-contract/my-wave-portal/contracts/WavePortal.sol) 

### ****Setting gas limit****

基本上 Metamask 将尝试估计交易将使用多少 gas。但是，有时它是错误的！

由于我们涉及到一些随机性，因此变得更加困难。因此，如果合约发送了奖品，那么由于我们运行的代码更多，因此波动者需要支付更多的 gas。

估计gas是一个难题，而一个简单的解决方法是设置一个限制

On App.js, I changed the line that sends the wave to

```jsx
wavePortalContract.wave(message, { gasLimit: 300000 })
```

这样做的目的是让用户支付 300,000 的定额 gas。而且，如果他们没有在交易中使用所有这些，他们将自动获得退款。
因此，如果一笔交易花费了 250,000 gas，那么在该交易完成后，用户未使用的剩余 50,000 gas 将被退还:)。

### 验证交易

如何验证智能合约是否按预期工作？

要进行验证，您可以在 [Rinkeby Etherscan](https://rinkeby.etherscan.io/) 上打开合约地址并查看已发生的交易。可以在这里找到各种有用的信息，包括调用的方法，在本例中为 Wave。

如果单击 Wave 交易，您会注意到在 To 属性中，它将识别出调用了合约地址。如果用户中奖了，您会在该字段中注意到，该合约已将 0.0001 ETH 从合约地址转移到您的账户地址。

请注意，交易的价值仍然是 0 ETH，因为用户从未支付任何费用来发起 wave。从智能合约内部转移 ETH 称为“内部交易”。

实时更新 Frontend UI :

I updated `getAllWaves` in `App.js.`

```jsx
const getAllWaves = async () => {
  const { ethereum } = window;

  try {
    if (ethereum) {
      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);
      const waves = await wavePortalContract.getAllWaves();

      const wavesCleaned = waves.map(wave => {
        return {
          address: wave.waver,
          timestamp: new Date(wave.timestamp * 1000),
          message: wave.message,
        };
      });

      setAllWaves(wavesCleaned);
    } else {
      console.log("Ethereum object doesn't exist!");
    }
  } catch (error) {
    console.log(error);
  }
};

/**
 * Listen in for emitter events!
 */
useEffect(() => {
  let wavePortalContract;

  const onNewWave = (from, timestamp, message) => {
    console.log("NewWave", from, timestamp, message);
    setAllWaves(prevState => [
      ...prevState,
      {
        address: from,
        timestamp: new Date(timestamp * 1000),
        message: message,
      },
    ]);
  };

  if (window.ethereum) {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();

    wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);
    wavePortalContract.on("NewWave", onNewWave);
  }

  return () => {
    if (wavePortalContract) {
      wavePortalContract.off("NewWave", onNewWave);
    }
  };
}, []);
```

当 Contract 引发 NewWave 事件时，我实际上可以“倾听”。就像一个 webhook。

我还可以访问有关该事件的数据，例如 message 和 From 。在这里，我在收到此 Events 时执行 `setAllWaves` ，这意味着当我们收到 Events 时，用户的 message 将自动附加到我的 allWaves 数组中，并且我们的 UI 将更新！

这是超级强大的。它让我们可以创建实时更新的网络应用程序! 想想如果你在区块链上制作 Uber 或 Twitter 之类的东西，实时更新的网络应用程序变得非常重要。